---
title: "Figure and table creation"
author: "Robert Schlegel"
date: "2019-06-10"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
csl: FMars.csl
bibliography: MHWNWA.bib
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(fig.width = 8, fig.align = 'center',
                      echo = TRUE, warning = FALSE, message = FALSE, 
                      eval = TRUE, tidy = FALSE)
```


## Introduction

In this final vignette we will go over the creation of the figures used in the publication for this research. These figures are largely adapted from the techniques seen in @Oliver2018tasmania (https://www.sciencedirect.com/science/article/pii/S0079661117303336) and @Schlegel2017predominant (https://www.frontiersin.org/articles/10.3389/fmars.2017.00323/full).

```{r libraries}
# Insatll from GitHub
# .libPaths(c("~/R-packages", .libPaths()))
# devtools::install_github("fabrice-rossi/yasomi")

# Packages used in this vignette
library(jsonlite, lib.loc = "../R-packages/")
library(tidyverse) # Base suite of functions
library(ncdf4) # For opening and working with NetCDF files
library(lubridate) # For convenient date manipulation
# library(scales) # For scaling data before running SOM
library(yasomi, lib.loc = "../R-packages/") # The SOM package of choice due to PCI compliance
library(data.table) # For working with massive dataframes

# Load functions written in previous vignettes
source("code/functions.R")

# Set number of cores
doMC::registerDoMC(cores = 50)

# Disable scientific notation for numeric values
  # I just find it annoying
options(scipen = 999)

# Set number of cores
doMC::registerDoMC(cores = 50)

# Disable scientific notation for numeric values
  # I just find it annoying
options(scipen = 999)

# Individual regions
NWA_coords <- readRDS("data/NWA_coords_cabot.Rda")

# The NAPA variables
NAPA_vars <- readRDS("data/NAPA_vars.Rda")

# Corners of the study area
NWA_corners <- readRDS("data/NWA_corners.Rda")

# Create smaller corners to use less RAM
  # This also better matches the previous South African work
  # The Tasmania work had corners of roughly 2 degrees greater than the study area
NWA_corners_sub <- c(NWA_corners[1]+8, NWA_corners[2]-8, NWA_corners[3]+8, NWA_corners[4]-8)

# The base map
map_base <- ggplot2::fortify(maps::map(fill = TRUE, col = "grey80", plot = FALSE)) %>%
  dplyr::rename(lon = long) %>%
  mutate(group = ifelse(lon > 180, group+9999, group),
         lon = ifelse(lon > 180, lon-360, lon)) %>% 
  select(-region, -subregion)

# Bathymetry data
  # NB: Should rather use model bathymetry
bathy <- readRDS("data/NWA_bathy_lowres.Rda")

# The grid that will convert the tri-polar coordinates to cartesian
  # NB: This file was created in the 'tikoraluk' project
load("data/lon_lat_NAPA_OISST.Rdata")

# Change to fit with this project
lon_lat_NAPA_OISST <- lon_lat_NAPA_OISST %>% 
  dplyr::select(-lon, -lat, -dist, -nav_lon_corrected) %>% 
  dplyr::rename(lon = nav_lon, lat = nav_lat) %>% 
  mutate(lon = round(lon, 4),
         lat = round(lat, 4)) %>% 
  mutate(lon_O = ifelse(lon_O > 180, lon_O-360, lon_O))

# Load MHW results
NAPA_MHW_sub <- readRDS("data/NAPA_MHW_sub.Rda")

# Events only
NAPA_MHW_event <- NAPA_MHW_sub %>%
  select(-clims, -cats) %>%
  unnest(events) %>%
  filter(row_number() %% 2 == 0) %>%
  unnest(events)
```

## Figure 1

The first figure we will want is that of the study area. This figure will have multiple panels show that we can show the overall average synoptic state of the important variables.

```{r old-code, eval=FALSE}
### TO DO
# Gulf Stream curved vector
# Halifax labelled point
# Text "Labrador Sea"
# Text: "Labrador Current"
# Interpolate pixels for visual nice-ness
# Improve bathymetry contours
  # Look into the new ggfriendly method
# One panel should contain current vectors
# And the other panel should contain bathymetry contours

# Mean variable states
system.time(
var_mean_states <- readRDS("data/NAPA_clim_vars.Rda") %>% 
  dplyr::select(-doy) %>% 
  group_by(lon, lat) %>% 
  summarise_all(.funs = "mean") %>% 
  ungroup() %>% 
  left_join(lon_lat_NAPA_OISST, by = c("lon", "lat")) %>% 
  dplyr::select(-lon, -lat) %>% 
  dplyr::rename(lon = lon_O, lat = lat_O) %>% 
  group_by(lon, lat) %>% 
  summarise_all(.funs = "mean", na.rm = T)
) # 12 seconds

# Vector mean states
system.time(
vec_mean_states <- readRDS("data/NAPA_clim_vecs.Rda") %>% 
  dplyr::select(-doy, -wo_clim) %>% 
  group_by(lon, lat) %>% 
  summarise_all(.funs = "mean") %>% 
  ungroup() %>% 
  left_join(lon_lat_NAPA_OISST, by = c("lon", "lat")) %>% 
  dplyr::select(-lon, -lat) %>% 
  dplyr::rename(lon = lon_O, lat = lat_O) %>% 
  group_by(lon, lat) %>% 
  summarise_all(.funs = "mean", na.rm = T) %>% 
  dplyr::rename(u = uoce_clim, v = voce_clim) %>% 
  mutate(arrow_size = ((abs(u*v)/ max(abs(u*v)))+0.2)/6)
) # 7 seconds

# The previous wind correction for when that info is brought in
# winds <- mutate(arrow_size = ((abs(u*v)/ max(abs(u*v)))+0.3)/6)

# Reduce wind/ current vectors
lon_sub <- seq(min(var_mean_states$lon), max(var_mean_states$lon), by = 1)
lat_sub <- seq(min(var_mean_states$lat), max(var_mean_states$lat), by = 1)
# currents <- currents[(currents$lon %in% lon_sub & currents$lat %in% lat_sub),]
vec_mean_states_sub <- vec_mean_states[(vec_mean_states$lon %in% lon_sub & vec_mean_states$lat %in% lat_sub),]

# Establish the vector scalar for the currents
current_uv_scalar <- 2

# Establish the vector scalar for the wind
wind_uv_scalar <- 0.5

# Wind feature vector coordinates
# cyc_atlantic <- data.frame(x = c(14.0, 16.1, 16.0), y = c(-36.0, -34.4, -32.1), 
#                            xend = c(16.0, 16.1, 14.0), yend = c(-34.5, -32.2, -30.6))
# cyc_indian <- data.frame(x = c(36.0, 33.9, 34.0), y = c(-31.5, -33.1, -35.4), 
#                          xend = c(34.0, 33.9, 36.0), yend = c(-33.0, -35.3, -36.9))
# westerlies <- data.frame(x = c(18.0, 21.1, 24.2), y = c(-38.0, -37.8, -37.8), 
#                          xend = c(21.0, 24.1, 27.2), yend = c(-37.8, -37.8, -38.0))

# The top figure (sea)
fig_1_top <- ggplot(data = map_base, aes(x = lon, y = lat)) +
  # The ocean temperature
  geom_raster(data = var_mean_states, aes(fill = sst_clim)) +
  # The bathymetry
  # stat_contour(data = bathy[bathy$depth < -100 & bathy$depth > -300,], 
               # aes(x = lon, y = lat, z = depth), alpha = 0.5,
               # colour = "ivory", size = 0.5, binwidth = 200, na.rm = TRUE, show.legend = FALSE) +
  # The current vectors
  geom_segment(data = vec_mean_states_sub, aes(xend = lon + u * current_uv_scalar, yend = lat + v * current_uv_scalar),
               arrow = arrow(angle = 40, length = unit(vec_mean_states_sub$arrow_size, "cm"), type = "open"),
                             linejoin = "mitre", size = 0.4) +
  # The land mass
  geom_polygon(aes(group = group), fill = "grey70", colour = "black", size = 0.5, show.legend = FALSE) +
  # The legend for the vector length
  # geom_label(aes(x = 37.0, y = -38.0, label = "1.0 m/s\n"), size = 3, label.padding = unit(0.5, "lines")) +
  # geom_segment(aes(x = 36.0, y = -38.3, xend = 38.0, yend = -38.3), linejoin = "mitre",
               # arrow = arrow(angle = 40, length = unit(0.2, "cm"), type = "open")) +
  # Halifax point and label
  # geom_point(data = SACTN_site_list, shape = 19,  size = 2.8, colour = "ivory") +
  # geom_text(data = SACTN_site_list[-c(3,4,7:9,18,21,23:24),], aes(label = order), size = 1.9, colour = "red") +
  # Ocean label
  # annotate("text", label = "ATLANTIC\nOCEAN", x = 13.10, y = -34.0, size = 4.0, angle = 0, colour = "ivory") +
  # Gulf stream line and label
  # geom_segment(aes(x = 17.2, y = -32.6, xend = 15.2, yend = -29.5),
               # arrow = arrow(length = unit(0.3, "cm")), size = 0.5, colour = "ivory") +
  # annotate("text", label = "Benguela", x = 16.0, y = -31.8, size = 3.5, angle = 298, colour = "ivory") +
  # Labrador Current line and label
  # geom_segment(aes(x = 33, y = -29.5, xend = 29.8, yend = -33.0),
               # arrow = arrow(length = unit(0.3, "cm")), size = 0.5, colour = "ivory") +
  # annotate("text", label = "Agulhas", x = 31.7, y = -31.7, size = 3.5, angle = 53, colour = "ivory") +
  # Labrador Sea label
  # annotate("text", label = "Agulhas\nBank", x = 22.5, y = -35.5, size = 3.0, angle = 0, colour = "ivory") +
  # Improve on the x and y axis labels
  scale_x_continuous(breaks = seq(-70, -50, 10),
                     labels = scales::unit_format(suffix = "°E", sep = ""),
                     position = "top") +
  scale_y_continuous(breaks = seq(35, 55, 10),
                     labels = scales::unit_format(suffix = "°N", sep = "")) +
  labs(x = NULL, y = NULL) +
  # Slightly shrink the plotting area
  coord_cartesian(xlim = NWA_corners_sub[1:2], ylim = NWA_corners_sub[3:4], expand = F) +
  # Use viridis colour scheme
  scale_fill_viridis_c(name = "Temp.\n(°C)", option = "D", breaks = seq(0, 25, 5)) +
  # Adjust the theme
  theme_bw() +
  theme(panel.border = element_rect(fill = NA, colour = "black", size = 1),
        axis.text = element_text(size = 12, colour = "black"),
        axis.ticks = element_line(colour = "black"))
fig_1_top

# The bottom figure (air)
fig_1_bottom <- ggplot(data = map_base, aes(x = lon, y = lat)) +
  # The ocean temperature
  geom_raster(data = var_mean_states, aes(fill = qt_clim)) +
  # The land mass
  geom_polygon(aes(group = group), fill = "grey70", colour = "black", size = 0.5, show.legend = FALSE) +
  # The current vectors
  # geom_segment(data = winds, aes(xend = lon + u * wind_uv_scalar, yend = lat + v * wind_uv_scalar),
               # arrow = arrow(angle = 40, length = unit(winds$arrow_size, "cm"), type = "open"),
               # linejoin = "mitre", size = 0.4) +
  # The legend for the vector length
  # geom_label(aes(x = 37.0, y = -38.0, label = "4.0 m/s\n"), size = 3, label.padding = unit(0.5, "lines")) +
  # geom_segment(aes(x = 36.0, y = -38.3, xend = 38.0, yend = -38.3), linejoin = "mitre",
               # arrow = arrow(angle = 40, length = unit(0.2, "cm"), type = "open")) +
  # The sub/regions
  # geom_polygon(data = NWA_coords, aes(group = region, fill = region, colour = region), alpha = 0.2) +
  # South Atlantic Anticyclone
  # annotate("text", label = "SOUTH\nATLANTIC\nANTICYCLONE", x = 13.5, y = -33.5, size = 3.0, angle = 0, colour = "ivory") +
  # geom_curve(data = cyc_atlantic, aes(x = x, y = y, xend = xend, yend = yend), curvature = 0.2, colour = "ivory",
             # arrow = arrow(angle = 40, type = "open", length = unit(0.25,"cm"))) +
  # South Indian Anticyclone
  # annotate("text", label = "SOUTH\nINDIAN\nANTICYCLONE", x = 36.5, y = -34.0, size = 3.0, angle = 0, colour = "ivory") +
  # geom_curve(data = cyc_indian, aes(x = x, y = y, xend = xend, yend = yend), curvature = 0.2, colour = "ivory",
             # arrow = arrow(angle = 40, type = "open", length = unit(0.25,"cm"))) +
  # Westerlies
  # annotate("text", label = "WESTERLIES", x = 22.5, y = -37.0, size = 3.0, angle = 0, colour = "ivory") +
  # geom_curve(data = westerlies, aes(x = x, y = y, xend = xend, yend = yend), colour = "ivory",
             # arrow = arrow(angle = 40, type = "open", length = unit(0.25,"cm")), curvature = -0.01) +
  # Improve on the x and y axis labels
  scale_x_continuous(breaks = seq(-70, -50, 10),
                     labels = scales::unit_format(suffix = "°E", sep = "")) +
  scale_y_continuous(breaks = seq(35, 55, 10),
                     labels = scales::unit_format(suffix = "°N", sep = "")) +
  labs(x = NULL, y = NULL) +
  # Scale bar
  # scaleBar(lon = 22.0, lat = -29.5, distanceLon = 200, distanceLat = 50, distanceLegend = 90, dist.unit = "km",
           # arrow.length = 100, arrow.distance = 130, arrow.North.size = 3, 
           # legend.colour = "ivory", arrow.colour = "ivory", N.colour = "ivory") +
  # Slightly shrink the plotting area
  coord_cartesian(xlim = NWA_corners_sub[1:2], ylim = NWA_corners_sub[3:4], expand = F) +
  # Use viridis colour scheme
  scale_fill_viridis_c(name = "Net\ndownward\nheat flux", option = "A") +
  # Adjust the theme
  theme_bw() +
  theme(panel.border = element_rect(fill = NA, colour = "black", size = 1),
        axis.text = element_text(size = 12, colour = "black"),
        axis.ticks = element_line(colour = "black"))
fig_1_bottom

# Convert the figures to grobs
fig_1_top_grob <- ggplotGrob(fig_1_top)
# fb_inset_grob <- ggplotGrob(fb_inset)
fig_1_bottom_grob <- ggplotGrob(fig_1_bottom)

# Stick them together
fig_1 <- ggplot() +
  # First set the x and y axis values so we know what the ranges are
  # in order to make it easier to place our facets
  # coord_equal(xlim = c(1, 10), ylim = c(1, 10), expand = F) +
  # Then we place our facetsover one another using the coordinates we created
  annotation_custom(fig_1_top_grob,
                    xmin = 1, xmax = 10, ymin = 5.5, ymax = 10) +
  # annotation_custom(fb_inset_grob,
                    # xmin = 3.5, xmax = 5.5, ymin = 7.2, ymax = 8.8) +
  annotation_custom(fig_1_bottom_grob,
                    xmin = 1, xmax = 10, ymin = 1, ymax = 5.5)
fig_1
# save
# ggsave(plot = fig_1, filename = "graph/fig_1.pdf", height = 8, width = 8)
```


## Figures 2 to 4

In these next figures we want to show the results of the SOM. These figures will contain 12 panels each and we will need to cleverly combine certain variables so as to limit the number of figures we will create.

```{r som-panel-fig, eval=FALSE}
# Load data packet
all_anom <- readRDS("data/packet_all_anom.Rda")

# Load SOM packet for anomaly data
som_all_anom <- readRDS("data/som_all_anom.Rda")

# Determine node index
node_index_all_anom <- event_node_index(all_anom, som_all_anom)

# Create and save mean synoptic states per node
node_mean_all_anom <- som_unpack_mean(all_anom, som_all_anom)

# From the SOM vignette
som_node_visualise <- function(sub_var = "sst_anom", viridis_option = "D"){
  
  # Subset data
  node_mean_all_anom_sub <- node_mean_all_anom %>% 
    filter(var == sub_var) %>% 
    mutate(lon = plyr::round_any(lon, 0.25),
           lat = plyr::round_any(lat, 0.25)) %>% 
    group_by(node, lon, lat, var) %>% 
    summarise(val = mean(val, na.rm = T))

  # Create plot
  som_panel_plot <- ggplot(node_mean_all_anom_sub, aes(x = lon, y = lat)) +
    # geom_point(aes(colour = val)) +
    geom_raster(aes(fill  = val)) +
    geom_polygon(data = map_base, aes(group = group), show.legend = F) +
    geom_label(data = node_index_all_anom, aes(x = -60, y = 35, label = paste0("n = ",count))) +
    # geom_polygon(data = NWA_coords, aes(group = region, fill = region, colour = region), alpha = 0.1) +
    coord_cartesian(xlim = NWA_corners_sub[1:2],
                    ylim = NWA_corners_sub[3:4], 
                    expand = F) +
    scale_fill_gradient2(low = "blue", high = "red") +
    # scale_colour_viridis_c(option = viridis_option) +
    labs(x = NULL, y = NULL, fill = sub_var) +
    facet_wrap(~node, ncol = 4) +
    theme(legend.position = "bottom")
  return(som_panel_plot)
}
```


## Figure 5

This figure needs to provide a detailed breakdown of the meta data behind the synoptic states being clustered into the 12 node panels. This means that we want to be able to show, primarily, during which seasons the MHWs in each node were occurring. This is shown effectively in Figure 7 of @Oliver2018tasmania. But it would also be good to show other meta data, such as MHW metrics, as seen in Figure 5 of @Schlegel2017predominant. It may be that we want both. Or it may be that the metric summary could be done via a table.

```{r seasonal-info-fig, eval=FALSE}
### TO DO
# Calculate season based on peak of event
# Left join tables for event number, sub/region, node
# Create visuals for the nodes

# Load data packet
all_anom <- readRDS("data/packet_all_anom.Rda")

# Load SOM packet for anomaly data
som_all_anom <- readRDS("data/som_all_anom.Rda")

# Determine node index
node_index_all_anom <- event_node_index(all_anom, som_all_anom) %>% 
  mutate(event_no = as.numeric(event_no))

# MHW season of (peak) occurrence and other meta-data
NAPA_MHW_meta <- NAPA_MHW_event %>% 
  mutate(month_peak = lubridate::month(date_peak, label = T),
         season_peak = case_when(month_peak %in% c("Jan", "Feb", "Mar") ~ "Winter",
                                 month_peak %in% c("Apr", "May", "Jun") ~ "Spring",
                                 month_peak %in% c("Jul", "Aug", "Sep") ~ "Summer",
                                 month_peak %in% c("Oct", "Nov", "Dec") ~ "Autumn"),
         sub_region = as.character(sub_region)) %>% 
  left_join(node_index_all_anom, by = c("region", "sub_region", "event_no"))
  
# Proportion of MHWs in each season in each node
node_prop_info <- NAPA_MHW_meta %>% 
  dplyr::select(region:event_no, month_peak:count) %>% 
  group_by(node, season_peak) %>% 
  mutate(node_season_prop = round(n()/count, 2)) %>% 
  select(season_peak:node_season_prop) %>% 
  unique() %>% 
  ungroup()

# Fill in the blanks
node_prop_grid <- expand.grid(unique(node_prop_info$season_peak), 1:12) %>% 
  dplyr::rename(season_peak = Var1, node = Var2) %>% 
  mutate(season_peak = as.character(season_peak)) %>% 
  # left_join(NWA_coords, by = "") %>% 
  left_join(node_prop_info, by = c("node", "season_peak")) %>% 
  mutate(count = replace_na(count, 0),
         node_season_prop = replace_na(node_season_prop, 0))

# Proportion of MHWs in each season in each region
region_prop_info <- NAPA_MHW_meta %>% 
  dplyr::select(region:event_no, month_peak:count) %>% 
  group_by(node, region) %>% 
  mutate(region_node_prop = round(n()/count, 2)) %>% 
  select(region, node, count, region_node_prop) %>% 
  unique() %>% 
  ungroup() #%>% 
  # right_join(data.frame(node = 1:12), by = "node")
  # right_join(NWA_coords, by = "region")

# Fill in the blanks
region_prop_grid <- expand.grid(unique(region_prop_info$region), 1:12) %>% 
  dplyr::rename(region = Var1, node = Var2) %>% 
  mutate(region = as.character(region)) %>% 
  left_join(NWA_coords, by = "region") %>% 
  left_join(region_prop_info, by = c("region", "node")) %>% 
  mutate(count = replace_na(count, 0),
         region_node_prop = replace_na(region_node_prop, 0))

# Join node info to region coordinates to keep ggplot happy
# NWA_coords_more <- left_join(NWA_coords, region_prop_info)

# som_season_runner <- ggplot()

som_season_plot <- ggplot() +
  # geom_point(aes(colour = val)) +
  # geom_raster(aes(fill  = val)) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), show.legend = F) +
  geom_polygon(data = region_prop_grid, aes(group = region, x = lon, y = lat, fill = region_node_prop), colour = "black") +
  geom_label(data = region_prop_grid, aes(x = -60, y = 35, label = paste0("n = ",count))) +
  # geom_label(data = filter(node_prop_grid, season_peak == "Winter"),
  #            aes(x = -60, y = 35, fill = node_season_prop, label = "Winter"), colour = "white") +
  # geom_label(data = filter(node_prop_grid, season_peak == "Spring"),
  #            aes(x = -55, y = 35, fill = node_season_prop, label = "Spring"), colour = "white") +
  # geom_label(data = filter(node_prop_grid, season_peak == "Summer"),
  #            aes(x = -50, y = 35, fill = node_season_prop, label = "Summer"), colour = "white") +
  # geom_label(data = filter(node_prop_grid, season_peak == "Autumn"),
  #            aes(x = -45, y = 35, fill = node_season_prop, label = "Autumn"), colour = "white") +
  # geom_label(data = node_index_all_anom, aes(x = -60, y = 35, label = paste0("n = ",count))) +
  # geom_polygon(data = NWA_coords, aes(group = region, fill = region, colour = region), alpha = 0.1) +
  coord_cartesian(xlim = NWA_corners_sub[1:2],
                  ylim = NWA_corners_sub[3:4], 
                  expand = F) +
  scale_fill_distiller(palette = "BuPu", direction = -1) +
  # scale_fill_viridis_c(option = "C") +
  # scale_colour_viridis_c(option = viridis_option) +
  labs(x = NULL, y = NULL, fill = "Proportion of events\nper region per node") +
  facet_wrap(~node, ncol = 4) +
  theme(legend.position = "bottom")
som_season_plot
ggsave(som_season_plot, filename = "output/som_season_plot.pdf", height = 12, width = 13)
```


## Figure 6

The following code is for creating meta-data visualisations of the MHW metrics for each node.

```{r extra-info-fig, eval=FALSE}
# Calculate the season during the peak of the event
# Join tables that have sub/region + season + node
# Think of a way to visualise this information
  # Or just copy Eric

# Calculate mean and median per node for plotting
node_h_lines <- NAPA_MHW_meta %>% 
  group_by(node) %>% 
  summarise(mean_int_cum = mean(intensity_cumulative, na.rm = T),
            median_int_cum = median(intensity_cumulative, na.rm = T))

# Create the figure
som_lolli_plot <- ggplot(data = NAPA_MHW_meta, aes(x = date_peak, y = intensity_cumulative)) +
  geom_lolli() +
  geom_point(aes(colour = season_peak)) +
  geom_label(aes(x = as.Date("2007-01-01"), y = 450, label = paste0("n = ", count,"/",length(node))), 
             size = 3, label.padding = unit(0.5, "lines")) +
  geom_hline(data = node_h_lines, aes(yintercept = mean_int_cum), linetype = "dashed") +
  # geom_hline(data = node_h_lines, aes(yintercept = median_int_cum), linetype = "dotted") +
  facet_wrap(~node) +
  labs(x = "", y = "Cummulative intensity (°Cxdays)", colour = "Season") #+
  # theme_grey() +
  # scale_y_continuous(expand = c(0, 100)) +
  # theme(strip.background = element_rect(fill = NA),
  #       panel.border = element_rect(fill = NA, colour = "black", size = 1),
  #       axis.text = element_text(size = 12, colour = "black"),
  #       axis.ticks = element_line(colour = "black"))
# som_lolli_plot
ggsave(som_lolli_plot, filename = "output/som_lolli_plot.pdf", height = 9, width = 10)
```


## Figure 7

This figure should summarise what all of the other figures have shown by using arrows going form one direction to the other across the 12 panels of the SOM. It may make sense to put the bullet points that would make up Table 1 into the panels of this figure.


## Table 1

This table will show a synopsis of what each node appears to portray. It will be primarily modelled after Table 4 of @Oliver2018tasmania.

```{r interpretation-table, eval=FALSE}

```


## Appendix

### Figures

It may be good to create a reference multi-panel figure for each event, as seen in @Schlegel2017predominant. But given that there are nearly 700 events being considered, this is likely too much. Perhaps showing the top 100 or some sort of meaningful reduction

```{r appendix-fig, eval=FALSE}
# Create synoptic figure for each event

# Load SACTN data
load("~/data/SACTN/AHW/SACTN_clims.Rdata")
load("data/SACTN/SACTN_events.Rdata")
load("setupParams/SACTN_site_list.Rdata")

# The files for loading
event_idx <- data.frame(event = dir("data/SOM", full.names = TRUE),
                        x = length(dir("data/SOM")))

# Create a synoptic atlas figure for each MHW
system.time(plyr::ddply(event_idx, c("event"), synoptic.fig, .progress = "text")) # 539 seconds
```

